优化部分一：DAG图分析
未优化前代码如下：
*	@_12	x	c
+	@_13	@_12	z
*	@_14	y	2
-	@_15	@_13	@_14
=	y	@_15	 
*	@_16	x	c
-	@_17	@_16	z
*	@_18	y	2
+	@_19	@_17	@_18
=	z	@_19	 
*	@_20	x	c
+	@_21	@_20	z
*	@_22	y	2
-	@_23	@_21	@_22
=	x	@_23	 
+	@_24	i	1
=	i	@_24

优化后代码如下：
=	@_48	z	 
=	@_47	y	 
*	@_14	@_47	2
=	@_49	x	 
*	@_12	@_49	c
+	@_13	@_12	@_48
-	y	@_13	@_14
*	@_18	y	2
-	@_17	@_12	@_48
+	z	@_17	@_18
+	@_21	@_12	z
-	x	@_21	@_18
=	@_50	i	 
+	i	@_50	1

说明：通过DAG图明显的删除了公共子表达式，例如乘法部分，将可以复用的临时变量@_12,@_16,@_20全部用@_12代替。

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――


优化部分二：窥孔优化
未优化代码如下：
+	$sp	$sp	12
+	$sp	$sp	4

优化后代码如下：
+	$sp	$sp	16

说明：窥孔优化用于合并运行栈操作时的冗余代码。在生成初始四元式时，每次在函数常量和变量声明部分都会对运行栈进行操作，将空间预留给常量和变量。而每次执行的代码顺序是读完这一行的声名后检查是否下一行还是声名。每次一声名都需要操作运行栈。例如下面的代码：
int a;
int b;
int c;
int d;
int e[2];
此时未优化的代码为：
+	$sp	$sp	4
+	$sp	$sp	4
+	$sp	$sp	4
+	$sp	$sp	4
+	$sp	$sp	12
优化后的代码将其计算结果合并：
+	$sp	$sp	28


――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――


优化部分三：寄存器分配
寄存器分配方法为引用计数（没有考虑循环，可以实现全局变量的寄存器分配）。
由于这部分代码是在翻译过程中杂糅参与的，因此不太方便进行代码优化前后的对比，在此用新的代码说明。

代码会统计每一个块中被调用的次数前三的变量，记录下变量名和变量地址，将变量分别用$t7,$t8,$t9代替。选用三个寄存器的原因是，由于寄存器的分配是全局的，即每一次跳转到新的一个代码块时，寄存器就需要分给新的代码块使用，这就导致原先存在代码块中的内容被冲突。因此需要在跳转之前将值先存到内存中，再跳转，跳转结束后再将值取出来，这个存取的代码量就会比原代码多出 2 * regNum * block 条代码，其中2 * regNum指sw和lw总共需要新增的代码量，block是一共划分出来的代码块。

优化前目标代码：
lw $t0,16($s3)
addi $t1,$t0,1

优化后目标代码：
addi $t1,$t8,1
其中$t8为保存的16($s3)对应的变量
